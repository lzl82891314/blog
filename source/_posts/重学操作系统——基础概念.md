---
title: 重学操作系统——基础概念
url_name: os-basics
date: 2021-09-24 08:35:01
categories:
  - 操作系统
tags:
  - 操作系统
  - 基础知识
---

## 前言

最近发生了几件事，让我意识到自己的操作系统知识简直是弱爆了。

一是正在学 Golang，学到 goroutine 时，完全不知道线程和协程的区别是什么，看书看文章看的是云里雾里，根本不知道里面说的各种用户态，和心态，性能差异到底是什么，只有零碎的知识点，看一遍忘一遍。

<!-- more -->

二是之前和一个同事争论了 C#中 Task 模型的实现方式，我说 C#中只要创建了 Task 就会启动一个新线程执行 Task 中的程序，最终通过线程上下文同步将执行结果同步至主线程，其 Task 的调用原理是一个状态机，程序执行时不断扫描状态机结果。然而我同事说，C#中的 Task 并不是一定会启动新线程，主要区分 Task 中的执行内容，如果是 IO 密集型操作，是不会启动新线程的。然后我就蒙了，发现自己根本不知道什么是 IO 密集型操作，什么是 CPU 密集型操作。（可能不光是操作系统吧，我把 C#中的 TAP 模型也学的一塌糊涂）

三是之前我的 WPF 项目在启动时，总是时不时报 `Not enough quota is available to process this command` 异常，导致项目启动失败，网上的结果都是说我 PC 的虚拟内存分页大小设置的太小了，让我改大一点，好家伙我就跟着教程改了一遍，改完发现自己改的是虚拟内存的容量大小，而不是虚拟内存的分页大小，并且改完之后这个错误，从之前的第一次启动报错，第二次解决变成了 100%异常彻底没法用了…没办法，之后又改回了 Auto 凑合着用着。但是比较奇怪，我和同事的系统和硬件几乎一模一样，为什么所有人都是好的只有我的程序时好时坏？带着这个问题我就开始调查自己和别人的系统差异，发现只有我装了 Wallpaper Engine，我关了之后发现问题瞬间解决。网上找了一下 Wallpaper Engine 的原理，发现就是在桌面的后面又通过 win32.dll 提供的接口启动了一个窗口盖在了屏幕后面。而 WPF 程序底层也是调用这个 Win32.dll，那我觉得问题应该就是 Wallpaper 的调用占用了 WPF 程序的资源导致的。但这也只是皮毛，没有啥本质研究，因为从配置虚拟内存分页开始，我就发现自己对虚拟内存这个概念十分模糊，以自己认为的逻辑去理解虚拟内存，现在发现完全解释不了分页大小是什么这些问题。

哎，带着以上的问题，痛定思痛，我决定从头再学一次操作系统。我承认自己大学时候学这个纯粹在应付考试，脑子里也只能记住零碎的知识点，没有成为完整的知识链。所以这次打算边学边记录，希望全部学完，能解答我上面提出的所有问题。

### 学习资料

工欲善其事必先利其器，我不是一个擅长看书学习的人，可能自己有一点点的阅读障碍症，所以我还是习惯于通过视频学习。为此，我找到了以下的几个很不错的操作系统学习资料（这里感谢 B 站的大数据帮我自动推送出清华大学的公开课）：

- [【清华大学】操作系统 陈渝](https://www.bilibili.com/video/BV1wW41117GS)
- [王道计算机考研 操作系统](https://www.bilibili.com/video/BV1YE411D7nH)
- [CS-Notes](https://github.com/CyC2018/CS-Notes)

我打算以清华公开课为主，第一遍学习操作系统的主题知识，王道考研为辅，补充零散的知识点（王道考研的笔记脑图整理的非常好，非常适合拿来主义），最后在写成 blog 之前，通过 CS-Notes 回顾重点知识点，希望这一次，我能顺利毕业。

所有教材的第一篇，基本都是在讲操作系统的基础概念，然后我发现自己对什么用户态核心态，内核，并发什么的概念都很模糊，所以补齐这些知识盲区和误区，对以后的学习也是很有帮助的。

## 发展史

我一直再说的观点就是知识不应该只去记零散的点，而是应该从头到尾形成一条记忆链，这样才不容易遗忘。之前写云技术那篇 Blog 时，就是以这样的形式从无到有学习的。同样，发展史记录了操作系统的初始和演进，是一个知识体系的头结点，所以应该去学习。

### 手工操作阶段

操作系统其实是和计算机共同发展的，在这个阶段还没有操作系统，计算机都是需要纸带进行输入输出的巨型设备，那个时期操作计算机的不应该叫程序员应该叫操作员，他们的任务是把记录程序的纸带输入到计算机中，当计算机执行结束后再将结束同样输出到纸带中。

![computer-by-manual](https://image.dunbreak.cn/os/computer-by-manual.png)

### 批处理阶段

这个阶段开始，操作系统的概念开始逐步诞生。在这个阶段初期，人们为了解决上述的速度矛盾，将多个单一的纸带合并为了一个磁带，并且将磁带输入计算机，之后在输出。这时的系统被称为`单道批处理系统`，这个时期操作系统刚诞生，但是它当时主要的任务是协助计算机正确加载磁带。

这之后，进入了`多道批处理阶段`。这个阶段人们发现，很多任务其实是可以并发执行的，即输入和输出数据时，CPU 其实是空闲，那么有没有可能，在第一个任务执行的同时输入第二个程序，在第一个程序执行结束后 CPU 可以无缝衔接第二个程序继续执行，并且并不会影响第一个程序的输出。

在这个阶段有两个主要的操作系统特征出现，一个是`中断`一个是`并发`。当有输入设备进行输入时，正在执行中的操作系统需要通过中断发起 IO 操作，并且 IO 和执行程序是在同一个时间段内发生的，这个特征就是并发，这两个特征后面会详细说明。

以下有一个例子可以很好地说明单道批处理和多道批处理之间的性能差异。

如果同时执行三个需要 1 秒完成读写执行的任务，在单道批处理阶段，我们可以看到完成这三个作业需要 9 秒：

![batch-handle-01](https://image.dunbreak.cn/os/batch-handle-01.png)

而同样的作业如果在多道批处理系统中执行，由于`并发`的产生，时间会缩短到 5 秒：

![batch-handle-02](https://image.dunbreak.cn/os/batch-handle-02.png)

### 分时系统

批处理系统虽然有效的提高了 CPU 利用率太低的问题，但是人际交互的能力很差，因为它并不能将程序全部输入计算机，必须一个执行结束再输入第二个，因此人们希望计算机能够同时执行多个任务，这也就是分时系统。

在此系统中，CPU 资源会被切分成很小的时间片比如 1ms，然后依次分为计算机内所有需要执行的程序。由于人感知不到这么短的时间，所以对人来说，这些程序就是在并发执行的。需要说明一点是，操作系统是由时钟外设记录时间并且触发中断进行程序切换的。

### 实时系统

分时系统已经很好地利用系统资源并且提供了很好的人机交互能力了，但是它并不能提供任务优先级的能力，因为并不是说计算机内的每个程序都是同等优先级的，有的任务需要立刻执行完毕，有的任务却没那么重要。为了满足这个需求，就有了实时操作系统。

其核心应该是利用多级反馈队列算法管理进程，对进程的优先级进行分级进行处理。并且实时系统还分为硬实时系统，比如导弹系统，自动驾驶系统等这些必须在规定时间内完成的系统；还有软实时即尽量在特定时间完成任务的系统。

同时，也是这个阶段，由于 CPU 和硬件的价格持续下降，计算机进入了 PC 时代。当然除了 PC 系统之外还有网络系统，分布式系统等，但这些系统没有演进操作系统的概念，因此就不单独说了。

最后，可以通过下图来简单了解操作系统的进化史：

![os-development](https://image.dunbreak.cn/os/os-development.png)

## 基本特征

从发展史中我们可以看出，操作系统是随着需求的变化逐步发展的，并且最终出现了以下四个基本的特征。

### 并发

并发就是我们工作中所说的并发，即`一个时间段内`存在多个程序共同执行

此概念区别于`并行 Parallel`，并行是在`一个时刻`同时有两个程序执行，单核 CPU 是无法实现并行的，但是可以实现并发，其原理就是时间片轮转

### 共享

共享就是资源共享，主要分两种，互斥共享和同时共享。

1. 互斥共享推进了锁、信号量、管程等技术的出现，主要是通过这些技术实现一个时间段内只有一个程序访问共享资源
2. 同时共享就是字面意思，一个资源在同一时刻可以由多个程序共同使用，比如边玩游戏边听歌，扬声器同时会播放两种音乐，这里扬声器就是同时共享资源

### 虚拟

这里所说的虚拟和虚拟化技术不是一个概念。主要分两个部分，`时分复用`和`空分复用`，这里的时空就是算法概念下的`时间`和`空间`。

1. 时分复用是将 CPU 资源进行拆分，让每个程序轮流使用，每次执行一小段时间比如 50ms，并且会快速切换，让人感觉程序就是在并行执行的
2. 空分复用技术就是虚拟内存技术，操作系统将硬盘等外部存储虚拟化为虚拟内存，在程序执行时进行页面置换操作，使得 8G 的内存也可以同时运行超过 8G 的程序，其核心原理是`局部性原理`（内存管理的重点，后续的 blog 中会说明）

### 异步

这里的异步和编程中说到的异步也不是一个概念，而是说操作系统中的程序不是一步到位执行结束的，而是依赖于虚拟技术轮流执行一段，走走停停地向前推进

## 内核状态

### 什么是内核

内核其实就是计算机最底层的软件，是操作系统的核心功能。这写程序都是计算机能正常运行必须要有的程序，主要可以分一下几类：

![kernel-categories](https://image.dunbreak.cn/os/kernel-categories.png)

以 Linux 为例，Linux 其实可以分为 Kernel 和 Shell，其中 Kernel 就是系统内核程序，而我们操作输入指令的 Shell 其实就是一个命令解释器，它解析操作系统为各个指令封装好的 API 提供给 Kernel 运行。

> 一个小插曲，我之前一直不知道 Shell 和 Bash 的区别是啥，其实它们都是 Shell 程序，而 Shell 这个概念在 Unix 诞生之前就出现了，之后 Unix 的 Shell 维护者叫 Brian J. Fox，他在为 Unix 编写 Shell 时一语双关将 Bourne shell 改为了 Bash，意为 Bourne-Again Shell

而操作系统内核也是分为为内核和大内核两类的，其中微内核就是仅把必须要写在内核中的程序划分为内核程序，其余的程序都放在了用户态，其好处就是内核轻便易于维护，而缺点是性能差，因为需要大量的系统调用使用户态和内核态交互。

而大内核正好与此相反，其区别可以在下图中看到：

![os-structure](https://image.dunbreak.cn/os/os-structure.png)

### 用户态 和 内核态

之前看 Golang 说协程的时候，总是提到什么内核态用户态的概念，当时看的是云里雾里，其实这里说的`内核态`和`用户态`其实是 CPU 指令集的状态。

我们知道，CPU 其实执行的一条一条的指令，一个 C 语言的语句被编译后会变成汇编语言，一条汇编语言就对应着一个 CPU 指令。多个指令组合在一起，会形成一个指令集，硬件设备商为这些指令集进行了权限划分，以 Inter 为例，CPU 指令集被分为 ring 0 ~ ring3 一共 4 个级别。其中 ring 0 是最高权限级别，可以操作所有的 CPU 指令集，Linux 系统采用 ring 0 和 ring3 两个权限。综上，对于 Linux 来说，ring 0 就是内核态， ring 3 就是用户态。

我们自己写的程序都是运行在用户态的，无法获取到内核态的指令，只有操作系统有权限调用内核指令。

这样拆分的主要目的是为了安全性，因为操作系统是计算机唯一能完全信任的程序，用户编写的程序都是不可信的，不能让其轻易获得内核态的指令，为此人为的加入了内核态和用户态的限制。

但是这些切分是有代价的，因为用户态和内核态都需要维护一套内存、堆栈寄存器、句柄等资源，之间是无法共享的。当程序由用户态切换到内核态时，会发生内存拷贝，并且内核态的程序运行结束后，如果有返回，依然是发生内存拷贝，其代价是很大的。也就因此有了这个面试问题：[阿里二面：什么是 mmap？](https://mp.weixin.qq.com/s/sG0rviJlhVtHzGfd5NoqDQ)

## 交互

上面说了我们写的代码只能执行在用户态，那么像把 Hello World 输出到屏幕上这样的程序应该如何执行呢？这就引出了程序和系统的交互问题。

用户态的程序只有三个途径可以和内核交互，即`系统调用`、`中断`以及`异常`。

### 系统调用

系统调用是用户态的程序在执行中，需要对内核指令进行操作时向操作系统发起的，上述说到的输出字符串到屏幕就需要用户程序发一起一个操作屏幕输出的系统调用。

上一节也说过了，系统调用需要进程上下文从用户态切换到内核态，其需要拷贝内存堆栈句柄寄存器等一系列资源，是有开销的，但是与安全性相比，这些开销是必要的。

系统调用可以同步或异步地`由用户态进程发出`。

### 中断 和 异常

中断也分为外中断和内中断，内中断就是指`异常`，其处理逻辑都是相同的，只不过`由用户态发起`的中断是外中断，由`CPU 执行指令的内部事件引起触发`的中断是异常。

当用户态程序执行中触发系统中断时，操作系统会把正在运行程序的资源进行临时记录，从而去执行中断程序，当中断程序执行结束后，操作系统会通过之前记录的资源还原回中断之前的状态，继续执行之前的程序。

举一个可以很好描述中断的例子：我们可以把正在执行的程序看做是一个正在做饭的厨师，他正在按照菜谱（程序）做饭，这时，他的儿子突然进来告诉他自己的手被蜜蜂咬了。那么这个厨师只能先停下手头的工作（系统中断），去拿家里的医药箱给儿子上药。上完药之后，他就继续回去做饭。

此外，系统中断和系统调用都会有对应的编号，以系统中断举例：系统中断由硬件和操作系统协同配合完成，其中系统中断是由硬件发起的，硬件会像系统设置一个中断标记，CPU 读取到对应的标记后，会从操作系统内建的中断表中查找对应的中断号，从而进一步执行系统中断。当 CPU 执行中断时，原本的应用会被暂停，应用中的数据会被操作系统记录在寄存器中，当系统中断执行结束后，操作系统还需要取出寄存器的数据将其还原回去。
