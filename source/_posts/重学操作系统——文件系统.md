---
title: 重学操作系统——文件系统
url_name: os-file
date: 2021-10-04 15:49:36
categories:
  - 操作系统
tags:
  - 操作系统
  - 基础知识
---

终于到了操作系统的最后一个功能模块了。不过这一部分也是我最陌生的内容，我都不记得大学期间学习过相关的知识点，对于文件系统，我一直以为就是管理文件类型怎么让操作系统识别的，现在学完反过来再看，真是弱爆了。

<!-- more -->

## 文件系统

文件系统是一种用于持久性存储的系统抽象，即 将文件更方便的存储在计算机中。主要有以下三大部分内容：

1. 分配文件：包括`管理文件块`（哪一块属于哪一个文件）、`管理空闲空间`（哪一块是空闲的）以及`文件分配算法`（分配策略）
2. 管理文件：包括`定位文件`及内容、`文件命名`（通过名字找到文件的接口）、`文件分层系统`以及`文件系统类型`（组织文件的不同方式）
3. 提供用户便利性：包括`文件保护`（分层保护数据安全）和 `可靠性/持久性`（保持文件的持久，及时发生崩溃、媒体错误、攻击等）

## 文件

当然，文件就是文件系统所管理的实体了。书面点说，文件就是件系统中的一个单元的相关数据在操作系统中的抽象。

> 我刚毕业的时候一直以为只有 txt 才算文件，其他的那些什么 word 之类的都是程序…

文件一般包括名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间等一系列`元数据`，这些元数据一般保存在`文件头`或者文件块中。操作系统可以根据文件头跟踪哪一块存储块属于逻辑上文件结构的哪个偏移。

对用户来说，文件就是一个持久化的数据结构，对系统访问接口来说，文件就是字节的集合，对操作系统内部来说，文件就是块的集合（块是逻辑转换单元，而扇区是物理转换单元），并且 _块的大小_ **不等于** _扇区大小_。 在 Unix 中， 块的大小是 4kb。

所以这其间其实存在转换的关系，这个具体的转换逻辑都是由文件系统完成的。比如：我们想要读取一个文件的第 1 个字节，这个操作为操作系统来说，它其实是读取了文件第 1 个字节的块中的所有数据，而对于底层的磁盘来说，真正读取的其实是文件块所在的扇区。因此，文件系统中的所有操作都是在整个块空间上进行的，如下图所示：

![file-block](https://image.dunbreak.cn/os-file/file-block.png)

### 文件别名

由于一个文件可能在不同场景需要满足不同的需求，因此一个文件可以起别名。以 Linux 为例，文件别名主要是以下两种实现方式：

1. 硬链接：即将多个文件项指向同一个文件，我理解中的 rsync 其实做的就是这个操作，对外看起来是完全不同的文件，但其实最终指向同一个文件
2. 软连接：以类似于 windows 下的快捷方式指向其他文件，与硬链接不同软连接其实就是一个文件路径，文件系统是通过这个路径去查找不同文件的

如果将一个有别名的文件删除，则因别名的实现方式不同，其结果也不同：

1. 删除硬链接文件：其实最终是无法全部删除的，因为硬链接方式会对文件存储引用计数，删除了对应的文件其实只是将计数减 1，只有当计数为 0 时才能真正删除
2. 删除软连接文件：如果删除的是软连接，则软连接会形成悬空指针指向一个空地址

此外，如果别名设置不当可能会形成环，这是文件系统不能接受的，因此在创建别名时，文件系统都会通过循环检测算法来判断是否会形成环。

### 文件描述符

我们日常编程中使用文件一般都是先”打开文件“，再”读取文件“内容，使用结束后再”关闭文件“，比如下的伪代码：

```cpp
f = open(name, flag);
...
read(f, ...);
...
close(f);
```

其中，`open`函数的返回值`f`就是`文件描述符`。文件描述符是一个整型的数字，操作系统为每一个进程维护了一个`打开文件表`，文件描述符就是这张表的 index，操作系统就可以通过 index 获取到文件的元数据信息。

当执行`open`函数打开文件之后，操作系统还需要如下的元数据来操作文件，这些元数据都是存储在打开文件表中的：

1. 文件指针：指向最近的一次读写位置，每次打开了这个文件的进程都使用这个指针
2. 文件打开计数：记录文件打开的次数。当最后一个进程关闭了文件时，允许将其从打开文件表中移除（因为允许多个文件同时开打同一个文件）
3. 文件磁盘位置：缓存数据访问信息
4. 访问权限：每个程序访问模式信息（比如读、写、执行、删除、列举等）

### 目录

目录时一类特殊的**文件**，文件是以目录的方式组织起来的。每一个目录都包含了一张表*<name, pointer to file header>*。早期的目录都是扁平的只有一层，现在文件系统的目录都是树型结构。

目录的一般操作有：搜索文件、创建文件、删除文件、枚举目录、重命名文件、在文件系统中遍历路径。这些操作都是以应用程序发出**系统调用**的形式完成，目录中路径的遍历是文件系统中一个很大的开销，因为必须一层一层读取文件块，需要频繁地进行 IO 操作。

文件系统也可以通过挂载的方式把不同的文件系统挂载到当前文件系统中，其中的挂载点就是一个目录，比如 Linux 系统中的`mount`操作（挂载的具体实现很复杂）。

### 文件系统类型

文件系统依照使用场景，实现方式等其实由很多种类别。比如对于磁盘来说， Windows 下支持早期的 FAT 和现在 NTFS，Linux 系统下使用 ext2/3/4，光盘文件系统 ISO9660 等。

除此之外，还有各种网络/分布式文件系统，日志文件系统，数据库文件系统，以及特殊文件系统等。这里需要说一下，Linux 中给用户提供进程信息的其实就是一个名为`proc`的特殊文件系统，其以“文件”的形式提供进程的运行信息。

#### 虚拟文件系统

上面说到了系统存在很多中不同的类型，如果用户需要对每一个文件系统进行适配开发，那工作量就非常复杂了。为此，操作系统都会为用户层提供一个虚拟文件系统，它其实就是对底层文件系统的一层抽象 api，用户只需要调用类似于`open`，`read`，`close`之类的函数就可以处理文件了，至于底层到底使用的是哪一种文件系统用户并不需要关注。

![virtual-file-system](https://image.dunbreak.cn/os-file/virtual-file-system.png)

虚拟文件系统一般有以下几个数据结构，这些数据结构一般会缓存在内存中：

1. 卷控制块（Unix：superblock）：每个文件系统会有一个，其中记录了文件系统的详细信息，包括块、块大小、空余块、计数/指针等
2. 文件控制块（Unix：vnode 或 `inode`）：每个文件会有一个，其中记录了文件的详细信息，包括许可、拥有者、大小、数据库位置等
3. 目录节点（Linux：dentry）：每个目录项一个，作用是将目录项数据结构及树型布局编码成树型数据结构，其中包括指向文件控制块的指针、父节点、项目列表等

具体结构如下图所示：

![file-layout](https://image.dunbreak.cn/os-file/file-layout.png)

## 文件分配

文件分配也有和内存管理类似的分配算法。其原因是为了能够兼容大文件和小文件能够同时被用户无感知的访问。分配算法主要解决的问题是：

1. 大多数文件都很小，需要对小文件提供强力的支持，因此块空间不能太大
2. 一些文件非常大，必须支持（64-bit 文件偏移）大文件，并且大文件的访问需要很高效

分配算法的指标有`高效（外部碎片小）`和`访问速度快`。不过总体没有内存管理那么繁杂，总体可以分为三类。

### 连续分配

连续分配一般使用数组，类似于内存管理中的连续分配，是直接开辟硬盘中的连续空间供文件存储。这种方式的优点就是简单高效，并且能够很好的支持随机访问。但是缺点是很难扩展。

可以看到这种方式基本可以类比于*数组*。

此外，如果配合磁盘使用，那么连续存储还有一个很明显的优点是顺序读写的速度很快，因为磁盘不用来回寻找磁道，在一次移动中就可以把数据全部读取。

综上，一般在只读的情况下比如 CD-ROM 会使用这种分配方式。

![continuous-allocation](https://image.dunbreak.cn/os-file/continuous-allocation.png)

### 链式分配

类比于上述的连续分配，链式分配基本可以类比于*链表*。

其优点也和链表很相似，可以很容易的增删改，并且没有外部碎片。当然缺点也很明显，就是不支持随机访问，想要找到一个文件中的一个随机的位置，必须要从文件的头部遍历才行。

此外，还有一个致命性的问题是这种分配方式**不可靠**，因为如果链式分配中的一个链因为某种原因断了，那么整个文件就不可访问了。

![chain-allocation](https://image.dunbreak.cn/os-file/chain-allocation.png)

### 索引分配

最后一种分配方式是索引分配，这种类似于页表的分页方式。磁盘中有专门的索引块来存储对应的索引项，对文件读写时，需要先通过索引项才能找到最终的文件内容。

这种方式的好处就是可以很好的解决上述的两个读写随机访问以及可靠性等问题。这种方式也就是数据结构中的`升维思想`，对于一维无法解决的问题，我们可以升维到二维解决。

索引项就是一维二维的概念，在底层磁盘的基础上多了一维索引块。

当然这种方式也是有缺点的：

- 对大文件来说，索引块的大小是固定的，如果一个文件过大，超出了索引块的大小，那么则无法正确分配。
- 对小文件来说，索引的创建也是需要额外的控件开销的，小的文件可能文件内容都比不上索引的内容

为了解决大文件分配的问题，和页表一样，出现了**多级索引块**。

![index-allocation](https://image.dunbreak.cn/os-file/index-allocation.png)

## 多磁盘管理

多磁盘管理就是 **RAID**，之前一直不了解这个概念到底是什么，总是看到微博上的一些做外设的人发什么磁盘阵列弄一个家庭数据中心之类的东西，看起来很高大上的样子。学习了这部分内容我才知道其实也没什么。

### 硬盘结构

说 RAID 之前需要先提前了解一下物理硬盘的工作原理。物理硬盘一般由一下几个结构组成：

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

![hard-disk-01](https://image.dunbreak.cn/os-file/hard-disk-01.png)

磁盘工作时，_整个磁盘都在转动_，并且*主轴也会带着磁头前后移动*，为的就是定位文件的磁道位置，之后在对应的扇区中读写文件。

但是一个磁盘的可靠性很低，很可能受到了物理撞击等问题就会导致数据错误，并且需要磁盘转动以及磁头移动才能确定文件位置，而一个磁盘的转动速度最快也就那样，和计算机 CPU 之类的电子元件还是差着好几个数量级。

为此，伯克利大学的大佬就再想能不能通过多个便宜的磁盘解决这两个问题。为此，磁盘矩阵 RAID 就出现了。

RAID 主要分为*RAID-0*，_RAID-1_，_RAID-4_，*RAID-5*等等，这后面的数字其实就是 RAID 的组成类型。

### RAID-0

最开始的 RAID-0 的组织方式是为了增加磁盘的速写速度的。

其工作原理是，将本来需要存在一个磁盘上的大文件，分段平均存储在多个不同的磁盘中。因此磁盘变成了多份，因此读取文件的速度也就变成了多份，最终将每一个磁盘读取到的文件内容合并就得到了想要的最终文件。

![raid-0](https://image.dunbreak.cn/os-file/raid-0.png)

### RAID-1

RAID-1 的实现目的是为了解决*可靠性*，就是将本来 应该写到一个磁盘中的数据 double 成多份，这样就算一个磁盘的数据坏了，将另一个磁盘的数据覆盖到之前的磁盘就可以了，算是一种备份策略。

当然这样做的代价就是写数据时需要写多份。

![raid-1](https://image.dunbreak.cn/os-file/raid-1.png)

### RAID-4

那既然这样，是不是有更好的方式能把 RAID-0 和 RAID-1 的好处结合起来一起使用呢？RAID-4 就是这样的组合方式。

RAID-4 是以 RAID-0 的方式将文件分别存储在多个磁盘中，比如下图存在 4 个磁盘中，在此基础上，增加了一个奇偶校验磁盘。如果有一个磁盘数据出错了，那么通过奇偶校验磁盘可以很容易的将之前的数据恢复。

![raid-4](https://image.dunbreak.cn/os-file/raid-4.png)

### RAID-5

当然，RAID-4 也是有一些缺点的，就是校验磁盘很容易成为瓶颈，并且只能为一个错误的磁盘工作，如果同时有两个磁盘数据出错，那么 RAID-4 就无法恢复数据了。

那就出现了 RAID-5，就是把就校验的块均匀的分散在各个磁盘中，使得每个磁盘校验的开销是一致的。

![raid-5](https://image.dunbreak.cn/os-file/raid-5.png)

## 磁盘调度

磁盘调度的目的是为了增加磁盘的读写速度。上一节已经大致说了磁盘的工作原理，我们可以通过下面的图继续看一下磁盘的详细构造：

![hard-disk-02](https://image.dunbreak.cn/os-file/hard-disk-02.png)

定位磁道的时间被称为*寻道时间*，从扇区的开始到找到文件目的地所花的时间被称为*旋转延迟*。

由于旋转速度是硬盘的物理参数操作系统无法改变，因此减少寻道时间就是提高文件读写速度的方法。由于文件的访问时随机的，因此磁头所在的位置也是随机的，让磁头在尽可能少的移动中找到文件，就是磁盘调度算法的目的。

### 先来先服务

学了这么长时间的操作系统，只要和调度算法有关的逻辑，最简单的一定是先来先服务。

这种调度就是那个文件先到，就先读取哪个文件。为此，有可能看到磁头在磁盘中频繁的前后移动，使得总的*移动距离是最长*的。虽然简单，但是是最低效的调度算法。

![disk-fcfs](https://image.dunbreak.cn/os-file/disk-fcfs.png)

### 最短服务优先

和进程调度一样，最短服务优先方式是优先读写距离磁头位置最短的文件。

这样做确实能够有效的减少磁头移动的距离，但是和内存管理一样，很可能导致距离远的文件饥饿，这种现象被称为“磁臂粘着”。

![disk-spn](https://image.dunbreak.cn/os-file/disk-spn.png)

### SCAN（电梯调度算法）

SCAN 算法的原理是，不让磁头连续的前后移动，而是每次都是从最开始移动到最后，再从最后移动到最前。这种直上直下的方式类似于电梯，因此又被称为*电梯调度算法*。

![disk-scan](https://image.dunbreak.cn/os-file/disk-scan.png)

在 SCAN 的基础上，又出现了 _C-SCAN_，就是每次只走一个方向，意思就是每次机试从头移动到尾，之后瞬间回到头继续从头到尾地移动。这样做的好处是公平并且可以提高效率。

![disk-c-scan](https://image.dunbreak.cn/os-file/disk-c-scan.png)

当然，这种方式也是可以改进的，因此出现了 _C-LOOK_ 的方式，即每次磁头只会移动到最远的一个文件块位置，而不是移动到最后，这样就节省了一段移动距离，提高了效率。

![disk-c-look](https://image.dunbreak.cn/os-file/disk-c-look.png)

## 写在最后

至此，整个操作系统的学习就基本告一段落了。这几天的学习可以说是受益匪浅，可能是我太弱了吧，课程中的很多内容，在我工作了几年之后才能完全明白到底是要干啥。第一次在大学学习这门课的时候可以说就是听了个响，能记住的，也就是为了考试的一个个零散的知识点。

并且，在学习并且把学习的内容写成笔记的过程中，又是一次成长的过程。对知识点的回顾以及纠错让我对课程中的概念有了更深的概念。

最后，课程最初提出的三个问题，全部课程学完之后，基本也都有了明确的答案，再次感谢 B 站给我推送了清华的公开课，讲的真的太棒了。
