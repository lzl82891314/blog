---
title: Go, 从入门到忘记
url_name: go-startup
date: 2021-11-18 15:05:38
categories:
  - Go
tags:
  - 入门
  - 基础知识
---

差不多整整一年前，当时在云组做了一个[Docker 和 Kubernetes 的培训](https://www.dunbreak.cn/2020/12/31/docker-and-kubernetes/)，当时就发现，云原生相关的组件几乎都是用 Go 写的，本着努力成为一个云原生程序员（笑）的目标，当时夸下海口说未来半年的考评任务要学会 Go 去看 Kubernetes 源码，然后就没有然后了……

<!--more-->

Go 最开始吸引我的是它号称`互联网时代的C语言`，第一次听到这个宣传语时，我下意识的以为 Go 是一门和 C 语言一样性能强大并且且可以直接操作硬件的语言。好家伙，学了之后才发现这句话的意思是说 Go 和 C 一样原始……

![hello-go](https://image.dunbreak.cn/go/hello-go.jpg)

作为一个 C#er，第一次看到 Go 的语法真是难受的浑身不爽，先不说别的，就单看这个 main 函数我就能发现奇怪的宝藏：`printf` + `%s`这种语法我可能大学毕业就再也没有用过了，然而这种过时的语法既然还能在 Go 这种 2007 年才发布的语言中看到，并且这种写法还是唯一支持的写法……

加之想到之前由于没有学习 Go Module 相关的内容导致我一个 main 函数都跑不起来的尴尬过往，说实话一年前夸下海口之后我是打算放弃的。

直到今年下半年，Barry 说要我做一个 Go 语言的培训我才重新开始学习 Go（果然 Deadline 才是第一生产力）。不过还好，当把所有 Go 的语法都学完并且自己动手写了一个小项目之后，发现 Go 语言中独特的抽象设计完全是给我打开了一扇新的大门，并且一切极简自己动手的风格也完全契合我想自己动手写点东西提高自己的想法，果然人人都是王境泽。

## 还是从头说起

### Go 是怎样诞生的？

果然我就是一个学任何东西都喜欢刨根问底的人（看书必看序，学习必须从诞生开始…），所以最开始还是来看看 Go 到底是如何诞生的。

话说早在 2007 年 9 月的一天，Google 工程师 [Rob Pike](https://en.wikipedia.org/wiki/Rob_Pike) 和往常一样启动了一个 C++项目的构建，按照他之前的经验，这个构建应该需要持续 1 个小时左右。这时他就和 Google 公司的另外两个同事 [Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson) 以及 [Robert Griesemer](https://en.wikipedia.org/wiki/Robert_Griesemer) 开始吐槽并且说出了自己想搞一个新语言的想法。当时 Google 内部主要使用 C++构建各种系统，但 C++复杂性巨大并且原生缺少对并发的支持，使得这三位大佬苦恼不已。

![authors](https://image.dunbreak.cn/go/authors.png)

第一天的闲聊初有成效，他们迅速构想了一门新语言：能够给程序员带来快乐，能够匹配未来的硬件发展趋势以及满足 Google 内部的大规模网络服务。并且在第二天，他们又碰头开始认真构思这门新语言。第二天会后，Robert Griesemer 发出了如下的一封邮件：

![plan-email](https://image.dunbreak.cn/go/plan-email.webp)

可以从邮件中看到，他们对这个新语言的期望是：**在 C 语言的基础上，修改一些错误，删除一些诟病的特性，增加一些缺失的功能。**比如修复 Switch 语句，加入 import 语句，增加垃圾回收，支持接口等。而这封邮件，也成了 Go 的第一版设计初稿。

在这之后的几天，Rob Pike 在一次开车回家的路上，为这门新语言想好了名字`Go`。在他心中，"Go"这个单词短小，容易输入并且可以很轻易地在其后组合其他字母，比如 Go 的工具链：goc 编译器、goa 汇编器、gol 连接器等，并且这个单词也正好符合他们对这门语言的设计初衷：简单。

> Go 从头到尾一直其实只有这一个名字，而现在人们知道的名字大多是 Golang，这其实是错的。Golang 其实是因为 Go 语言原本想要的官网域名 `https://www.go.org` 被占用了，无奈使用了 `https://www.golang.org`。此外，早起由于 Go 这个单词太普世了，导致搜索引擎很难搜索到 Go 语言相关的内容，所以 Golang 也有 SEO 的作用。但是不管这些，这门语言的名字就是 Go。

### 逐步成型

在统一了 Go 的设计思路之后，Go 语言就正式开启了语言的设计迭代和实现。

2008 年，C 语言之父，大佬肯·汤普森实现了第一版的 Go 编译器，这个版本的 Go 编译器还是使用 C 语言开发的，其主要的工作原理是将 Go 编译成 C，之后再把 C 编译成二进制文件。到 2008 年年中，Go 的第一版设计就基本结束了。这时，同样在谷歌工作的伊恩·泰勒（Ian Lance Taylor）为 Go 语言实现了一个 gcc 的前端，这也是 Go 语言的第二个编译器。

伊恩·泰勒的这一成果不仅仅是一种鼓励，也证明了 Go 这一新语言的可行性 。有了语言的第二个实现，对 Go 的语言规范和标准库的建立也是很重要的。随后，伊恩·泰勒以团队的第四位成员的身份正式加入 Go 语言开发团队，后面也成为了 Go 语言，以及其工具设计和实现的核心人物之一。

罗斯·考克斯（Russ Cox）是 Go 核心开发团队的第五位成员，也是在 2008 年加入的。进入团队后，罗斯·考克斯利用函数类型是“一等公民”，而且它也可以拥有自己的方法这个特性巧妙设计出了 http 包的 HandlerFunc 类型。这样，我们通过显式转型就可以让一个普通函数成为满足 http.Handler 接口的类型了。不仅如此，罗斯·考克斯还在当时设计的基础上提出了一些更泛化的想法，比如 io.Reader 和 io.Writer 接口，这就奠定了 Go 语言的 I/O 结构模型。后来，罗斯·考克斯成为 Go 核心技术团队的负责人，推动 Go 语言的持续演化。到这里，Go 语言最初的核心团队形成，Go 语言迈上了稳定演化的道路。

### 正式发布

2009 年 10 月 30 日，罗伯·派克在 Google Techtalk 上做了一次有关 Go 语言的演讲，这也是 Go 语言第一次公之于众。十天后，也就是 2009 年 11 月 10 日，谷歌官方宣布 Go 语言项目开源，之后这一天也被 Go 官方确定为 Go 语言的诞生日。

![published](https://image.dunbreak.cn/go/published.webp)

在 Go 开源后，它也有了一个属于自己的吉祥物 Gopher：

![Gopher](https://image.dunbreak.cn/go/gopher.webp)

Gopher 是一种地鼠，是 Rob Pike 的老婆设计的（写代码的人还有家人的支持，真是羡慕了笑），从此 Gopher 也成了世界各地 Go 程序员的象征。

### 运营至今

其实由于 Google 公司做背书，Go 在刚发布开始还是比较火热的。但是随时认识了解它的人越来越多，Go 的各种问题也逐步暴露了出来，比如：Go 最开始的设计只是为了解决 Google 公司自己内部的一些项目构建问题，其内部的系统是一个巨石架构，几乎不存在包依赖的问题，因此包依赖这个问题并没有在最开始成为 Go 开发团队的主要任务。

然而没有包管理的项目是恐怖的，在最开始的版本，Go 只支持 Go Env 的包管理模式，这种模式下，我们写的代码必须放在 Go 安装时设置的 Go Env 目录下。这几乎简直是一个反人类的设计，也是最开始我连一个 hello, world 都编译不成功的主要原因。

除此之外，由于没有包依赖管理，最开始 Go 项目的包是没有版本的概念的，也就导致了大多数的项目很难运行起来。随后，Go 团队引入了 vendor 模式，试图去解决这个问题，但是都只是杯水车薪。直到 Go1.11 的 Go Module 发布之后，Go 才彻底解决了包依赖的问题。

![main-version](https://image.dunbreak.cn/go/main-version.webp)

从上面的 Go 的几个主要版本可以看到，明年 2 月左右发布的 Go 1.18 版本将支持泛型，这也说明 Go 正在逐步成为一门更主流的语言。

## 学会打洞

Go 是一门致力于简单的语言，从最开始的 Hello, World 函数中我们可以大概知道如下几个概念：

1. 和 C#一样，块和块之前是由大括号区分的（不像 Python 那种面向游标卡尺编程的语言）
2. 和 C#不同，语句之后不用跟分号，如果加了，会自动被 Go 原生自带的代码格式化工具 gofmt 删掉 (go 从源头上根治了左括号到底换不换行这一世纪难题)
3. 同样和 C#不同，函数是一等公民，程序以包作为拆分载体，而不是 C#中以类和程序集。在 Go 中，文件可以大概等同于 C#的 Class；包可以大概等同于 C#的程序集。这个概念以我浅显的理解应该和 JavaScript 相同

好了，有了上述这些基础的概念，我们就可以正式学习如何当一名合格的地鼠了。不过，既然我们都已经是成熟的 C#er 了，那学习 Go 肯定不能从 int 是什么意思说起了，如何找一个切入点呢？

### 关键字

Go 的简单从关键字的个数上就可以很好的体现出来了。

Go 一共只有可怜的`25个关键字`，而我数了数 C#的，好家伙，基础关键字就有`77个`，除此之外还有`42个上下文关键字！`一共有 119 个关键字，这几乎是 Go 的 5 倍之多！

Go 语言中的 25 个关键字：

| break    | default     | func   | interface | select |
| -------- | ----------- | ------ | --------- | ------ |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

既然这样，那就以关键字为切入点，主要对比学习一下 Go 和 C#的关键字有哪些差别，进而来全面地学习一下 Go 的语法。为此，我主要把 Go 和 C#的关键字进行了分类，来按类别学习这些关键字的异同。

#### 咱俩都有的

- break
- case
- const
- continue
- default
- else
- for
- goto
- if
- interface
- return
- struct
- switch
- var

以上的 12 个关键字是 Go 和 C#共有的，它们之中大部分的用法都是完全相同的，这里主要说一下 Go 中有特殊语法的关键字。

##### var

首先，让我们来看看参数定义关键字 var。

var 的意思同样也是定义变量，但是定义变量的语法和 C#有所不同。C#中只有一种定义变量的方法，而 Go 中有两种，它们分别是：

- 普通方式

```go
var i int = 1
```

这种方式是 Go 的原始变量定义方式，一般包级别的变量都是这样定义的，并且如果定义那些编译器可以自动推断的类型，比如上述的例子，其后的类型可以省略。

由此可知，Go 中 var 就是申明一个变量，而这个变量是什么类型，需要在变量名之后指明。

- 语法糖(是的，Go 中也有语法糖…)

```go
i, j := 1, "hello"
```

上述的代码可以简写为这种语法糖形式，Go 代码中，90%的变量都是以这样的方式定义的，因为 Go 中几乎所有的函数都会存在多余一个的返回值，这样的定义可以省去很大功夫。

##### switch-case-default

switch-case 是一个连用的子句，但是 case 和 default 这两个关键字在 Go 中除了可以和 switch 连用，还可以和后面会讲到的 select 语句连用。

Go 中默认把 switch 语句的一个弊端修复了，即 switch 子句中不用再写 break 了：

```go
switch n := "a"; n {
  case n == "a":
    fmt.Println("a")
  case n == "b":
    fmt.Println("b")
  case n == "c":
    fmt.Println("c")
}
```

> 上面这段代码的 fmt 是标准输出包，其中的`Println`函数等同于 C#中的`Console.WriteLine`方法。

这段代码的最终结果只会输出`a`，而 C#中这样的代码会把 abc 全部输出出来，这样的改动确实比较省心。

除此之外，switch 语句后面出现了一个比较奇怪的写法`n := "a"; n`，在 Go 中的控制语句（if, else if, switch-case, for）都可以加入这样的控制块作用域代码，如此这样写的话，这个变量 n 就只能在 switch 语句中生效。分号之前是变量的定义，分号之后是定义的判断条件。

这种语法优点类似于 C#中的普通 for 循环的前两个子句。

最后，我们可以看到 switch 之后没有跟小括号，在 Go 中，控制块的子句后面都是不需要写小括号的，如果写了同样会被 gofmt 自动格式化掉。

##### for

Go 中的循环控制语句`有且只有`一个 for 关键字。而 C#中的 while、foreach 等在 Go 中都是通过 for 的各种变形达成的。

- while 语句

```go
for true {
  // ...
}
```

- for 语句

```go
for i := 0; i < n; i++ {
  // ...
}
```

Go 中普通的 for 循环和 C#几乎没有差别，唯一的差别就是 `i++从表达式变成了语句`。

这句话的意思是，Go 的代码中不能写`i = i++`这样的代码。

此外，也没有`++i`这样的语法，只有`i++`

- foreach 语句

```go
array := [5]int{1, 2, 3, 4, 5}
for index, value := range array {
  // ...
}
```

> 这个例子中用到了数组的初始化代码，数组会在后面单独说明，这里只是作为一个例子展示。

foreach 语句的写法和 C#中很不相同，上述的例子是 foreach 遍历一个 int 类型的数组，其中用到了一个`range`关键字，这个关键字会把数组拆分成两个迭代子对象 index 和 value，这个语法同样类似于 JavaScript 的循环语法。

##### struct

Go 中的 struct 关键字和 C#中的作用是相同的，即定义一个结构体。

上面我们提到了，Go 中是没有类这个概念的，那唯一承载 C#中 class 作用的定义就是 struct 了。

和 C#相同，struct 在 Go 中同样也是**值类型**结构，因此使用的时候一定需要注意案值传递导致的复制问题。

此外 Go 中的 struct 内**只能定义字段，不能定义函数**。

```go
// struct的定义是配合type关键字一起使用的
type People struct {
  name string   // 定义的字段和Go语言其他的风格相同，名字在前，类型在后
  age int
}
```

我们在 C#中很少会用到结构体，所有和结构体相关的功能都被类取代了，因为按值传递的特性一般很难控制，用好了就是性能之选，用不好就是性能陷阱。

但是 Go 中没有 class，所以在 Go 中，struct 就起到了 C#中 class 组织一些相关变量的功能。

再次强调一下，Go 的结构体只能定义字段。

##### 其他

1. return 关键字和 C#功能是相同的，这里拿出来是要说一下，Go 中的 return 同样也可以同时返回多个结果，Java 没有这样的语法代码写起来实在是费劲。
2. interface 没讲，这个关键字和 C#相同都是定义接口的，而 Go 中的接口实现方式和 C#完全不同，需要在后面详细说明，所以这里就简单带过。

其余没有说明的关键字用法和 C#完全相同，就不一一说明了。

#### 虽然不太一样但是意思差不多的

- package
- import
- type
- defer

##### package 和 namespace

上面已经提到了，Go 的函数是一等公民，因此，Go 比 C#少了一层类的封装，相对的，对函数的封装就体现在了包里。

Go 中的 package 就是定义组织一个包的，其目的和 C#的 namespace 基本是相同的，主要是对代码模块进行隔离。但是有一点和 C#不同，C#十分灵活，即是不在一个文件夹下的代码都可以定义为相同的 namespace。但是 Go 不行，Go 中 package 内的文件，都需要在相同的文件夹内才能被正确编译，并且一个文件夹内只能出现最多一个包名。

这里再额外说一下 main 包，类似于 C#中的 Main 方法，Go 中可运行程序的执行入口也是一个 main 函数，并且如果想要让程序顺利执行，main 函数必须定义在`package main`下。

##### import 和 using

这俩用法也基本是相同的，都是用来导入其他模块的代码来使用的。和 C#using 的是 namespace 相同，Go 中 import 的同样也是其他包的名字。

这里要说一个 Go 的强制要求：没有在代码模块中使用的 import 或者定义了但是没有使用的变量等，在 Go 编译时会直接报错。

这样做除了使代码看起来更简洁以外，最主要的原因是 import 语句除了引用其他包还有另一个功能就是调用包中的`init()`函数。比如如下代码：

```go
package demo

var me string

func init() {
	me = "jeffery"
}

func SayHello() {
	fmt.Printf("hello, %s", me)
}
```

> 这段代码中，定义了一个包级变量`me`，这种变量可以类比于 C#中的静态变量。

上述的程序定义了一个 demo 包，当 demo 包第一次被 import 关键字加载到其他包时，会自动调用其`init()`函数，这就优点类似于 C#中类的构造方法，这时就会把`变量me`赋值为`jeffery`，之后调用`SayHello()`函数时，返回的就都是"hello, jeffery"了。

也正是因为`init`函数的存在，不使用的 import 需要被删除，因为很有可能会自动调用到对应包内的 init 函数。

##### type 和 class

- 常规用法

把 type 和 class 对比其实是不太合理的。因为 C#中 class 关键字是定义一个类型并且定义这个类型的具体实现，比如下述的代码在 C#中的意思是定义一个名为 People 的类，并且定义了这类中有一个属性 Age。

```csharp
class interface IAnimal {
  public void Move();
}

class People {
  public int Age { get;set; }
}
```

然而 Go 中的 type 关键字仅仅是用来定义类型名称的，如果想要定义其实现，必须后面再更上具体实现的关键字。比如上述的代码定义在 Go 中就变成了如下：

```go
type IAnimal interface {
  Move()
}

type People struct {
  Age int
}
```

上述只是 type 的最常用用法，除此之外 type 还有两个其他的用法：

- 以一个基准类型定义一个新类型

```go
type Human People
```

这样的语句相当于用`People`类型定义了一个`Human`的新类型。**注意，这里是一个新类型，而不是 C#中的继承**。因此如果 People 内有一个 Move 函数，那 Human 对象是无法调用这个 Move 函数的，如果非要使用，则需要强制类型转换。

> Go 中的强制类型转换是类型 + ()，比如上述的例子 Human(People)就可以把 People 类型强转为 Human 类型。

- 定义类型别名

```go
type Human = People
```

如果使用了`等号`进行定义，那就相当于给类型 People 定义了一个别名 Human，这种情况下 People 中的代码 Human 也是可以正常使用的。

上面两种用法基本都不常用，这里只做了解即可。

##### defer 和 finally

Go 中的 defer 作用就是 C#的 finally，在一个方法执行结束退出之前，可以干一件事。

而和 C#不太一样的是，Go 中的 defer 语句不用必须写在最后，比如我们会经常看到这样风格的代码：

```go
var mutex sync.Mutex

func do() {
  mutex.Lock()
  defer mutex.Unlock()
  // ...
}
```

上面这个例子的意思是定义一个全局锁，在 do 函数进入时，加锁，在退出时解锁。之后再去写自己的业务逻辑。

除此之外，defer 也可以写多个，但最终的执行顺序是从下向上执行，也就是最后定义的 defer 先执行。

#### Go 有而 C#没有的

- chan
- go
- fallthrough
- func
- map
- range
- select

##### go 和 chan

这两个关键字是 Go 并发编程定义的关键字，具体的这部分会在后面的并发编程小节重点讲解。

##### fallthrough

这个关键字估计连职业 Go 开发工程师一辈子也用不了一次的那种。这个关键字完全是为了兼容 C 语言中的 fallthrough，其目的是是在 switch-case 语句中再向下跳一个 case，比如：

```go
switch n := "a"; n {
  case n == "a":
    fmt.Println("a")
    fallthrough
  case n == "b":
    fmt.Println("b")
  case n == "c":
    fmt.Println("c")
}
```

那这个例子的最终输出结果就是：

```bash
a
b
```

##### func

和其他函数是一等公民的语言（比如 JavaScript 的 function，Python 中的 def）一样，Go 中的 func 就是用来定义函数的。

```go
// 定义了一个函数名称为getName的函数
// 其中包含一个int类型的参数id
// 以及两个返回值，string和bool类型
func getName(id int) (string, bool) {
  return "jeffery", true
}
```

Go 中的函数以及其他一系列需要定义类型的语法中，永远都遵循**名称在前，类型在后**。

此外，Go 中的 func 同样也可以配合 type 使用定义 C#中的委托，比如我们可以在 C#中定义一个.Net Core 的中间件：

```csharp
public delegate void handleFunc(HttpContext httpContext);
public delegate handleFunc middleware(handleFunc next);
```

这样的代码可以在 Go 中这样实现：

```go
type handleFunc func(httpContext HttpContext)
type middleware func(next handleFunc) handleFunc
```

##### 其他关键字

1. `range`关键字在之前说 for 的地方已经提到过了
2. `map`关键字是用来定义 map 类型的，会在 Go 语言的特性中重点讲解
3. `select`关键字是 Go 并发编程的概念，会在 Go 并发编程中重点讲解

至此，我已经把 Go 中的 25 个关键字简单的一一概括了一下。到此为止，我们虽然还不能写出优雅的 Go 代码，但是至少我们应该可以看懂 Go 语言的一些语法概念了。

### 特殊的语言特性

基础的关键字都了解了之后，就需要开始学习一点 Go 语言中特殊的语言特性了。

#### 值传递和指针

这是一个需要**重点说明**的和 C#很不同的概念：`Go中的函数参数和返回值全都是按值传递的`。什么意思呢？比如下述的代码：

```go
type People struct {
  name string
}

func ensureName(p People) {
  p.name = "jeffery"
}

func main() {
  p := People{
    name: ""
  }
  ensurePeople(p)
  fmt.Println(p.name) // 输出：""
}
```

为啥上面这段代码没有把 p 的内容改掉呢？因为 Go 语言的值传递特性，ensureName 函数内收到的 p 已经是 main 函数中 p 的一个副本了。这就和 C#中把 p 改为一个 int 类型得到的结果一样。

那怎么解决呢？**用指针**。

不知道其他人怎么样，当我最开始学习 Go 的时候发现需要学指针的时候瞬间回想起了大学时期被 C 和 C++指针折磨的那段痛苦回忆…所以我本能的对指针就有一种排斥感，虽然 C#中也可以用指针，但是如果不写底层代码，可能写 10 年代码都用不到一次。

不过还好，Go 中对指针的使用进行了简化，没有复杂的指针计算逻辑，仅知道两个操作就可以很轻松的用好指针：

- "\*": 取地址中的内容
- "&": 取变量的地址

```go
var p *People = &People{
  name: "jeffery",
}
```

上述代码中，我创建了一个新的 People 实例，并且通过"&"操作获取了它的地址，把它的地址赋值给了一个\*People 的指针类型变量 p。

此时，p 就是一个指针类型，如果按照 C 或者 C++，我是无法直接操作 People 中的字段 name 的，但是 Go 对指针操作进行了简化，我可以对一个指针类型变量直接操作其内的字段，比如：

```go
func main() {
  fmt.Println(p.name)     // 输出：jeffery
  fmt.Println(*(p).name)  // 输出：jeffery
}
```

上述的两个操作是等价的。

有了指针，我们就可以很轻松的模拟出 C#那种**按引用传递参数**的代码了：

```go
type People struct {
  name string
}

func ensureName(p *People) {
  p.name = "jeffery"
}

func main() {
  p := &People{
    name: ""
  }
  ensurePeople(p)
  fmt.Println(p.name) // 输出：jeffery
}
```

依然以我个人的浅薄理解，我觉得 C#等语言的引用传值其实就是对类似于 Go 这种指针按值传值的语法糖，只不过 C#和 Java 封装了这些操作，让开发者能直接跳过指针这个概念。但是 Go 由于其追求简单，默认没有给开发者提供这样的支持。

#### 字符串

在 C#中字符串其实是 char 类型的数组，是一个特殊的分配在栈空间的`引用类型`。

而在 Go 语言中，字符串是**值类型**，并且**字符串是一个整体**。也就是说我们不能修改字符串的内容，从下面的例子可以很清楚的看出这一概念：

```csharp
var str = "jeffery";
str[0] = 'J';
Console.WriteLine(str);   // 输出：Jeffery
```

上述的语法在 C#中是成立的，因为我们修改的其实是字符串中的一个 char 类型，而 Go 中这样的语法是会被编译器报错的：

```go
str := "jeffery"
str[0] = 'J'  // 编译错误：Cannot assign to str[0]
```

但是我们可以用数组 index 读取对应字符串的值：

```go
s := str[0]
fmt.Printf("%T", s)   // uint8
```

可以看到这个返回值是`uint8`，这是为啥呢？其实，在 Go 中，string 类型是由一个名为`rune`的类型组成的，进入 Go 源码看到`rune`的定义就是一个 int64 类型。这是因为 Go 中把 string 编译成了一个一个的 UTF8 编码，每一个 rune 其实就是对应 UTF8 编码的值。

此外，string 类型还有一个坑：

```go
str := "李正龙"
fmt.Printf("%d", len(str))   //猜猜会输出多少？
```

> len()函数同样也是 go 的内置函数，是用来求集合的长度的。

上面这个例子会返回`9`…这是以为中文在 Go 中会编译为 UTF-8 编码，一个汉字的编码长度就 3，所以三个汉字就成了 9，但是也不一定，因为一些特殊的汉字可能占 4 个长度，所以不能简单用 len() / 3 来获取文字长度。

因此，汉字求长度的方法应该这样做：

```go
fmt.Println(utf8.RuneCountInString("李正龙"))
```

#### 数组

Go 中的数组也是一个我觉得设计的有点过于底层的概念了。基础的用法和 C#是相同的，但是细节区别还是很大的。

首先，Go 的数组也是一个**值类型**，除此之外，由于”严格地“遵循了数组是一段连续的内存的结合这个概念，**数组的长度是数组的一部分**。这个概念也很重要，因为这是直接区别于切片的一个特征。而且，Go 中的数组的长度只能是一个常量。

```go
a := [5]int{1,2,3,4,5}
b := [...]{1,2,3,4,5}

lena := len(a)
lenb := len(b)
```

上述是 Go 中数组的两个比较常规的初始化语法，数组的长度和字符串一样，都是通过`len()`内置函数获取的。其余的使用和 C#基本相同，比如可以通过索引取值赋值，可以遍历，不可以插入值等。

#### 切片

与数组对应的一个概念，就是 Go 中独有的`切片Slice`类型。

在日常的开发中几乎很好能用得到数组，因为数组没有扩展能力，比如 C#中我们也几乎用不到数组，能用数组的地方基本都用`List<T>`。

Slice 就是 List 的一种 Go 语言实现，它是一个**引用类型**，主要的目的是为了解决数组无法插入数据的问题。其底层也是一个数组，只不过它对数组进行了一些封装，加入了两个指针分别指向数组的左右边界，就使得 Slice 有了可以增加数据的功能。

```go
s1 := []int{1,2,3,4,5}
s2 := s1[1:3]
s3 := make([]int, 0, 5)
```

上面是 Slice 的三种常用的初始化方式。

1. 可以看到切片和数组的唯一区别就是没有了数组定义中的数量
2. 可以基于一个去切片去创建另一个切片，其后面的数字的含义就是目前业界通用的`左包含右封闭`
3. 可以通过**make()**函数创建一个切片

`make()`函数感觉可以伴随 Go 开发者的一生，Go 的三个引用类型都是通过 make 函数进行初始化创建的。对切片来说，第一个参数表示切片类型，比如上栗就是初始化一个 int 类型的切片，第二个参数表示切片的长度，第三个参数表示切片的容量。

想切片中插入数据需要使用到 append()函数，并且语法十分诡异，可以说是离谱到家了：

```go
s := make([]int)
s = append(s, 12345) // 这种追加值还需要返回给原集合的语法真不知道是哪个小天才想到的
```

这里出现了一个新的概念，切片的**容量**。我们知道数组是没有容量这个概念的（其实是有的，只不过容量就是长度），而切片的容量其实就类似于 C#中`List<T>`的容量（我知道大部分 C#er 在使用 List 的时候根本不会去关心 Capacity 这个参数），容量表示的是底层数组的长度。

> 容量可以通过 cap()函数获取

在 C#中，如果 List 的数据写满了底层数组，那会发生扩容操作，需要新开辟一个数组将原来的数据复制到新的数组中，这是很耗费性能的一个操作，Go 中也是一样的。因此在日常开发使用 List 或者切片的时候，如果能提前确定容量，最好就是初始化的时候就定义好，避免扩展导致的性能损耗。

#### map

Go 中除了把 List 内置为切片，同样也把 `Dictionary<TKey, TValue>`内置为了 map 类型。

map 是 Go 中三个**引用类型**的第二个，其创建的方式和切片相同，也需要通过 make 函数：

```go
m := make(map[int]string, 10)
```

从字面意思我们就可以知道，这句话是创建了一个 key 为 int，value 为 string，初始容量是 10 的 map 类型。

对 map 的操作没有像 C#那么复杂，get，set 和 contains 操作都是通过[]来实现的：

```go
m := make(map[string]string, 5)

// 判断是否存在
v, ok := m["aab"]
if !ok {
  //说明map中没有对应的key
}
// set值，如果存在重复key则会直接替换
m["aab"] = "hello"

// 删除值
delete(m, "aab")
```

这里要说个坑，虽然 Go 中的 map 也是可以遍历的，但是 Go 强制将结果乱序了，所以每次遍历不一定拿到的是相同顺序的结果。

#### 面向对象

##### 封装

终于说到面向对象了。细心的同学肯定已经看到了，Go 里面竟然没有封装控制关键字`public`,`protected`和`private`！那我这面向对象第一准则的封装性怎么搞啊？

Go 语言的封装性是通过**变量首字母大小写控制的**（对重度代码洁癖患者的我来说，这简直是天大的福音，我再也不用看到那些首字母小写的属性了）。

```go
// struct类型的首字母大写了，说明可以在包外访问
type People struct {
  // Name字段首字母也大写了，同理包外可访问
  Name string
  // age首字母小写了，就是一个包内字段
  age int
}

// New函数大写了，包外可以调到
func NewPeople() People {
  return People{
    Name: "jeffery",
    age: 28
  }
}
```

##### 继承

封装搞定了，继承怎么搞呢？Go 里好像也没有继承的关键字`extends`啊？

Go 完全以设计模式中的`优先组合而非继承`的设计思想设计了复用的逻辑，在 Go 中**没有继承，只有组合**。

```go
type Animal struct {
	Age int
	Name string
}

type Human struct {
	Animal      // 如果默认不定义字段的字段名，那Go会默认把组合的类型名定义为字段名
              // 这样写等同于： Animal Animal
	Name string
}

func do() {
	h := &Human{
		Animal: Animal{Age: 19, Name: "dog"},
		Name: "jeffery",
	}
	h.Age = 20
	fmt.Println(h.Age)        // 输出：20，可以看到如果自身没有组合结构体相同的字段，那可以省略子结构体的调用直接获取属性
	fmt.Println(h.Name)       // 输出：jeffery，对于有相同的属性，优先输出自身的，这也是多态的一种体现
	fmt.Println(h.Animal.Name)// 输出：dog，同时，所组合的结构体的属性也不会被改变
}
```

这种组合的设计模式极大的降低了继承带来的耦合，单就这一点来说，我认为是完美的银弹。

##### 抽象

在讲解关键字的部分我们就已经看到了，Go 是有接口的，但是同样没有实现接口的`implemented`关键字，那是因为 Go 中的接口全部都是**隐式实现**的。

```go
type IHello interface {
  sayHello()
}

type People struct {}

func (p *People) sayHello() {
  fmt.Println("hello")
}

func doSayHello(h IHello) {
  h.sayHello()
}

func main() {
  p := &People{}
  doSayHello(p) // 输出：hello
}
```

可以看到，上例中的结构体 p 并没有和接口有任何关系，但是却可以正常被`doSayHello`这个函数引用，主要就是因为 Go 中的所有接口都是隐式实现的。（所以我觉得真的有可能出现你写着写着突然就实现了某个依赖包的某个接口的情况）

此外，这里看到了一个不一样的语法，函数关键字 func 之后没有直接定义函数名称，而是加入了一个结构体 p 的一个指针。这样的函数就是结构体的函数，或者更直白一点就是 C#中的方法。

在默认情况下，我们都是使用指针类型为结构体定义函数，当然也可以不用指针，但是在那种情况下，函数所更改的内容就和原结构体完全不相关了。所以一般也遵循一个*无脑用指针*的原则。

好了，封装、继承和抽象都有了，至于多态，在继承那里已经看到了，Go 也是优先匹配自身的相同函数，如果没有才回去调用父结构体的函数，因此默认情况下的函数都是被重写之后的函数。

#### 被黑的最惨的设计哲学

至此，Go 的语法特性就已经全部介绍完了，最后让我来扒一扒*我认为*的 Go 的一些黑料。

Go 语言的设计哲学是`less is more`。这句话的意思是 Go 需要简单的语法，其中简单的语法也包括**显式大于隐式**（接口类型真是满头问号）。这是什么意思呢？

##### Go 没有默认的类型转换

```go
var i int8 = 1
var j int
j = i   // 编译报错：Cannot use 'i' (type int8) as the type int
```

还有一个例子就是 string 类型不能默认和 int 等其他类型拼接，比如输入`"n你好" + 1`在 Go 中同样会报编译错误。原因就是 Go 的设计者觉得这种都是隐式的转换，Go 需要简单，不应该有这些。

##### Go 没有默认参数，同样也没有方法重载

这也是一个很让人恼火语言特性。因为不支持重载，写代码时就不得不写大量可能重复但是名字不相同的函数。这个特性也是有开发者专门问过 Go 设计师的， 给出的回复就是 Go 的设计目标就是简单，在简单的大前提下，部分冗余的代码是可以接受的…

##### Go 不支持 Attribute

和目前没有泛型不同，Go 的泛型是一个正在开发的功能，是还没来得及做的。而特性 Attribute 也就是 Java 中的注解，在 Go 中是被明确说明不会支持的语言特性。

注解能在 Java 中带来怎样强大的功能呢？举一个例子：

在大型互联网都转向微服务架构的时代，分布式的多段提交，分布式事务就是一个比较大的技术壁垒。以分布式事务为例，多个微服务很可能都不是一个团队开发的，也可能部署在世界各地，而如果一个操作需要回滚，其他所有的微服务都需要实现回滚的机制。这里不光设计复杂的业务模型，还有更复杂的数据库回滚策略（什么 2PC 啊，TCC 啊每一个策略都可以当一门单独的课来讲）。

这种东西如果要从头开发那几乎是很难考虑全面的。更别提这样的复杂代码再**耦合**到业务代码中，那代码会变得非常难看。都不说分布式事务了，简单的一个内存缓存，我们用的都很混乱，在代码中会经常看到先读取缓存在读取数据库的代码，和业务完全耦合在一起，完全无法维护。

而 Spring Cloud 中，代码的使用者可以通过一个简单的注解（也就是 C#的特性）`@Transactional`，那这个方法就是支持事务的，使这种复杂的技术级代码完全和业务代码**解耦**，开发者完全按照正常的业务逻辑写业务代码即可，完全不用管事务的一些问题。

然而， Go 的设计者同样认为注解会严重影响代码使用者对一个调用的使用心智，因为加了一个注解，就可以导致一个函数的功能完全不一样，这与 Go 显式大于隐式的设计理念相违背，会严重增加使用者的心智负担，不符合 Go 的设计哲学（哎，就离谱…）

##### Go 没有 Exception

在 Go 中没有异常的概念，相反地提供了一个 error 的机制。

对 C#来说，如果一段代码运行存在问题，那我们可以手动抛出一个 Exception，在调用方可以**捕获**对应的异常进行之后的处理。

而 Go 中没有异常，替代的方案是 error 机制。什么是 error 机制呢？还记得之前讲过的 Go 的几乎所有的函数都有多个返回值吗？为啥要那么多的返回值呢？对，就是为了接收 error 的。比如下述代码：

```go
func sayHello(name string) error {
  if name == "" {
    return errors.New("name can not be empty")
  }
  fmt.Printf("hello, %s\n", name)
  return nil
}

// invoker
func main() {
  if err := sayHello("jeffery"); err != nil {
    // handle error
  }
}
```

这样的 error 机制需要保证所有的代码运行过程中都不会异常崩溃，每个函数到底执行成功了没有，需要通过函数的返回错误信息来判断，如果一个函数调用的返回结果的 error == nil，说明这段代码没问题。否则，就要手动处理这个 error。

这样就有可能导致一个严重的后果：所有的函数调用都需要写成`if err := function(); err != nil`这样的结构。这样的后果几乎是灾难性的（这也是为啥 VS2022 支持了代码 AI 补全功能后，网上的热评都是利好 Gopher…）

这种 error 的机制也是 Go 被黑的最惨的地方。

那这时候肯定有小伙伴说了，那我就是不处理搞一个类似于`1/0`这样的代码会怎么样呢？

如果写了类似于上述的代码，那最终会引发一个 Go 的`panic`。在我目前浅显的理解中，`panic`其实才是 C#中 Exception 的概念，因为程序运行遇到 panic 后就会彻底崩溃了，Go 的设计者在最开始的设计中估计是认为所有的错误都应该用 error 处理，如果引发了 panic 那说明这个程序无法使用了。因此 panic 其实是一个无法挽回的错误的概念。

然而，大型的项目中，并不是自己的代码写的万无一失就没有 panic 了，很可能我们引用的其他包干了个什么我们不知道的事就 panic 了，比如最典型的一个例子：Go 的 httpRequest 中的 Body 只能读取一次，读完就没有了。如果我们使用的 web 框架在处理请求时把 Body 读了，我们再去读取结果很有可能 panic。

因此，为了解决 panic，Go 还有一个 recover()的函数，一般的用法是：

```go
func main() {
  panic(1)
  defer func() {
    if err := recover(); err != nil {
      fmt.Println("boom")
    }
  }
}
```

在我看来，Go 完全就是自己把自己坑了，从最开始如果直接设计好 Exception 机制，就不用多此一举再处理 panic 了。

因为以上的种种设计哲学，使得 Go 目前是市面上争议最多的语言。Gopher 们把这种哲学奉为圭臬，而像我这种重度 C#语法糖患者看到这种设计就觉得离谱到家了。

其实 Go 有一个强大的竞争者——Rust，Rust 是 Mozilla 基金会在 2010 年研发的语言，和 Go 是以 C 语言为基础开发的类似，Rust 是以 C++为基准进行开发的。所以现在社区中就有 Go 和 Rust 两拨阵营在相互争论，吵得喋喋不休。当然，万物没有银弹，一切的事物都应该以辩证的思维去学习理解。

### 绝知此事要躬行

好了，我相信能坚持学习到这的同学都是真心想学习 Go 这门语言的，那么看完了上面那些 Go 的语法之后，肯定也会手痒写一点 Go 的代码练习练习，加深记忆。

正好，那就来实现一个 Go 官网中的一个小例子，自己动手实现一下这个计算 Fibonacci 数列第 N 个数的接口吧。

```go
type Fib interface {
	// CalculateFibN 计算斐波那契数列中第N个数的值
	// 斐波那契数列为：前两项都是1，从第三项开始，每一项的值都是前两项的和
	// 例如：1 1 2 3 5 8 13 ...
	CalculateFibN(n int) int
}
```

由于篇幅所限，这个小练习的[答案](https://github.com/lzl82891314/training-go-2/tree/main/src/fibonacci)我放在了自己的 github 中。

这个题的目的首先是为了让你快速熟悉 Go 的基础语法，另一个点，也是在考察算法功底。

计算 Fibonacci 第 N 个数的题其实是前两年比较火的一道面试题，如果面试过程中直接写了尾递归的形式那么恭喜你，基本和这个工作走远了。

尾递归的问题是算法时间复杂度是 O(2^n)，属于最高级别的复杂度。

因此为了优化这个问题，后续的可以使用 map 剪枝，因此也就练习了 map。但是使用 map 依然存在递归压栈这种问题，因此就需要继续优化将递归改写为循环。这样就练习了循环和切片的基础用法。当然如果想做到满分，肯定需要不低的算法功底的（背题的不算啊…）

通过这个小练习，我们还可以看到 Go 工具链中的性能测试功能，如下图：

![fibonacci](https://image.dunbreak.cn/go/fibonacci.webp)

这里我们调用了 Go 的基准测试包 Benchmark 的功能对上述四个算法进行了一一测试，从结果中我们可以看到每个算法的时间复杂度和空间复杂度，也可以看到一个问题的逐步优化的过程，我觉得这是一个很好地功能。

> go test -bench=. -benchmem

至此，Go 的基础语法部分就全部介绍完毕了。

## 如何优雅的钻进洞里

在互联网云时代，几乎所有叫的上名字的组件都是用 Go 开发的，比如 Docker、Kubernetes、Dapr 等等根本都列不完，但是如果就仅凭这些简单的语法是不可能捕获那些大厂的心的。Go 能在互联网时代这么火热，肯定是有自己的立命之本的，没错，就是 Go 的并发编程功能，Go 语言的最大杀器 **Goroutine**。

Goroutine 是一个合成词，取自原词`Coroutine`意为**协程**。

Goroutine 就是协程在 Go 中的一个实现，那协程究竟是什么呢？为啥最近几年才火起来呢？C#没有协程这个概念不是一样可以做 Web 开发么？为啥大厂纷纷从 Java 等大众的语言都投身有协程的 Go 呢？带着上述这些个问题，我开始从头了解协程究竟是个什么东西。

### 进程的出现

我是很早就听说过协程这个概念的，并且几次三番都想搞懂这个协程到底是个什么意思，但是由于前置知识的缺失，无法形成有用的知识链，不是看不懂，就是刚理解一点就忘。所以我觉得，应该从头来理解协程这个概念的诞生和为什么目前这么火热，才能最终把知识变为自己的经验。

因为要从头说起，那我觉得就应该从最开始为什么会有进程这个概念讲起。

话说在很早以前，计算机还是单道批处理的一个机器，程序员（或者可以称之为打孔员）将自己写好的程序通过纸袋打入计算机中，计算机计算完毕最终会把结果返回给用户。在这个时期其实是没有进程的概念的。

随着技术的不断发展，计算机也从最原始的样子逐渐进化到多道批处理系统。这个时候计算机已经可以并发的执行多个程序了，同时也出现了操作系统的概念。这个时候人们发现，单单用程序这个概念已经不能成功描述一个正在计算机内执行的程序了，因为一份程序可以多次并发地执行，那对于计算机来说，这些代码相同但是并发执行的程序就分别表示的是不同的程序，因此，聪明的脑袋就发明了进程这个概念。

在那个时期，进程是一个程序存在的唯一标识，其不仅作为程序的执行调度单元，同样也是程序信息的保存单元，每个进程都有一个进程控制块 PCB，内部存放的是这个进程的一些信息比如：页表、寄存器、程序计数器、堆、栈等等。

除此之外，进程和进程之间是相互隔离的，它们自身有着自己独立的 PCB 和内存等，几个进程之间互不干扰，完全独立地在计算机系统中运行着。

这个时期，一切都在相安无事的完美运行着。

### 线程的出现

但是随着技术进一步的发展，人们发现单单用进程已经解决不了一些问题了，比如：播放一个 MP3 音频文件。

一个 MP3 音频文件播放的伪代码大致如下：

```c
main() {
  while(true) {
    /*IO读取音频流*/
    Read();
    /*解压音频流*/
    Decompress();
    /*播放*/
    Play();
  }
}

Read() {...}
Decompress() {...}
Play() {...}
```

这段代码在进程中执行就存在一个很严重的问题了：无法让三个函数并发执行。因为在调用`Read`函数时，用户态代码就发出一个系统调用，进行 IO 操作。对于 IO 密集型的操作操作系统通常情况下都是会将其进程直接阻塞的，当 IO 操作完成触发一个中断，操作系统才会激活之前被阻塞的进程继续执行。

那这就有问题了，在我没有将文件全部读完全部解码完我这个程序是无法播放音频文件的。给用户带来的直接后果就是播放的声音是一段一段的。为什么是一段一段的？因为 IO 操作是有 buffer 的，每次可能只会 IO 一个 buffer 的数据，按照程序的逻辑，会把 buffer 中的数据解码，然后再播放。然后再 IO…那用户听到的就是一段一段的音乐了。

那有没有可能用多个进程实现呢？就是一个进程 IO，一个进程解码，一个进程播放。这看起来好像是一个解决方案，但是依然存在问题，即进程间通信。上一节我们知道了进程间的内存是相互隔离的，三个进程直接是无法直接访问对方的内容的，这就需要 IO 的进程执行完，需要想办法把自己的数据告诉解码的进程。且不说进程间通讯的性能消耗是巨大的，就连三个进程完美地协同工作其实都很难做到。

所以我们知道了，_单独的进程无法做到在共享内存的前提下并发执行多个不同的程序_。因此，线程这个概念就出现了。

为了解决上述问题，聪明的脑袋将进程的资源管理模块和调度模块进行了更细致的拆分，创建出了线程这个概念。这时，进程依然是一个程序的所有资源控制中心，但是程序的执行已经不是进程来做的了，而是丢个了自己内部的多个线程来完成。这些线程是共享内存的，并且又可以被 CPU 调度并发地执行多个不同的程序，上述这类问题就被线程完美地解决了。

虽然进程内的线程是共享内存的，但是线程的执行时相互独立的，因此每个线程就需要有自己的寄存器和程序计数器，堆栈等资源。因此，和进程控制块 PCB 相同，线程也有自己的线程控制块 TCB，来记录上述的一些自己独享的资源。进程和线程的模型如下图：

![process-thread](https://image.dunbreak.cn/go/process-thread.webp)

### 互联网时代

线程这个概念一直平稳运行到了互联网时代，这时，新的问题又出现了。

在互联网高速发展的现在，高并发已经是每个互联网企业必须要面对的问题了，因为有了高并发才有流量，有了流量才有自己企业的立命之本。而在高并发时代下，线程已经很难满足需求了。

因为如果一台服务器 1 秒中的并发量可达 10000 个，那么对应的服务器就需要开启至少 1 万个线程去服务这些并发请求。而线程的创建也是需要资源的，以 Linux 为例，一个 POSIX Thread 的创建成本是*1-8MB 不等*，那 1 秒 10000 个请求就需要在 1 秒内消耗掉*10-80GB*的内存资源，这个数量是十分恐怖的。

并且，CPU 从一个线程调度到另一个线程是需要线程上下文切换的，这也是一个性能损耗点。什么是上下文切换？我们上面说了，线程同样也有自己的 TCB 去记录自己的堆栈和程序计数器寄存器等。操作系统在进行线程调度时，需要从一个线程的 TCB 中将上述的所有资源加载到 CPU 执行的寄存器和内存中才能执行。当一个线程的时间片结束切换到另一个线程时，操作系统同样需要将上一个程序的最终资源信息记录回之前的线程 TCB 中，然后再加载新线程的 TCB 中的资源。这个过程被称为**线程的上下文切换**，这个开销一般在**3-5us 左右**。

除此之外，目前的互联网请求大多数都是需要读取数据的并且返回给用户展示的。那数据的读取就需要 IO 操作，IO 操作时操作系统又会将对应的线程阻塞，因此有人做过测试，高并发情况下，有 80%的线程其实都是阻塞状态的，它们只占资源缺不干活，白白占用了系统资源。并且如果内存不足操作系统可能会挂起进程，从而频繁地触发缺页中断，给了本就不宽裕的 IO 带宽更大的压力，形成了更严重的恶性循环。

早起的 Web 服务器 Apache 就是通过多线程响应的模型来处理 web 请求的。但是现在几乎没有人用 Apache 这个服务器了，因为那种模型无法解决上述的问题。

这时，聪明的脑袋又想到了新的解决方案：IO 多路复用技术。彻底取代 Apache 成为 Web 服务器程序王者的 Nginx 就是使用这种技术处理高并发请求的。那什么是 IO 多路复用呢？

IO 多路复用就是，和一个请求开一个线程不同，Nginx 这类服务器是通过一个死循环的线程去监听所有的 Web 请求，当有请求到来时，通过 Linux 的一些 IO 多路复用技术`select`,`poll`,`epoll`,`kqueue`等统一又那一个线程派发多个请求。并且，这些请求的执行线程都是非阻塞的 IO 操作，也就是遇到 IO 操作它们不是等，而是停下来去干别的事，这样就大大降低了服务器的压力。

但是这却又有一个新的问题产生了，即 IO 多路复用技术下，多个请求的响应是事件回调机制的，而处理这些程序的程序员很难去找到回调的时机，这让程序开发人员增加了无限高的心智压力，代码非常难写。

### 协程

为了解决以上的种种问题，我们的主角协程就出现了。

协程的本质其实就是**用户态的线程**。这里又来了一个新的概念，啥是用户态？

目前市面上的所有 CPU 指令集其实都是分级别的，一般分为 ring0~ring3 一共 4 个级别，离 ring0 越近，获得的 CPU 指令的权限就越大，相应能干的事就越多，但是对应的不安全的风险也就越高。由此我们可以知道，**用户态和内核态其实是完全隔离的**。

因此现在的操作系统都是分用户态和内核态的。以 Linux 为例，ring0 是内核态，ring3 即是用户态。我们日常开发的所有程序都是用户态程序，在用户态程序我们仅能操作计算机很小一部分的功能，大部分功能，比如 IO 读写，内存分配和各种硬件交互等等都是由内核程序完成的。

这时肯定有同学问了，哎不对啊，我的代码同样可以读文件并且把各种信息写在屏幕上啊？那是怎么实现的？

这些功能其实都是用户态程序向内核态程序发送各种不同的**系统调用**实现的。而发送一次系统调用，就会触发一次用户态到内核态的上下文切换，这同样也会带来一次性能损耗。

去年网上有一个阿里巴巴的二面面试题，问*为什么 RocketMQ 和 Kafka 的速度那么快？*其实是因为 RocketMQ 和 Kafka 在进行 IO 操作的时候都用到了 linux 中的一个 零拷贝技术 mmap，让数据读写过程中少一次系统调用切换带来的内存拷贝，而是映射到相同的一块内存区域，从而达到的加速。对这个问题感兴趣的同学可以去看 [什么是 mmap](https://mp.weixin.qq.com/s/sG0rviJlhVtHzGfd5NoqDQ)。

因此，在线程这个概念出现之前，就已经出现了用户态线程的概念，即用户态的程序内部自己模拟多线程的调度，操作系统仅仅是调度了对应的进程，却感知不到对应进程内的线程，协程带来的直接好处是*不需要创建 TCB 了*，可以节省下线程创建时对应的内存开销。

不过如果这么看来，协程就又是一个和 Docker 一样旧瓶装新酒的技术？还真不是。

早期的用户态线程虽然有一定的性能优势，但是还是解决不了一个问题：**无法感知系统中断**。我们知道，现在的操作系统都是*抢占式*的，操作系统会默认优先执行高优先级的程序，如果目前正在调度一个低优先级的程序，那操作系统会触发一个中断让高优先级的程序抢占它。抢占是操作系统通过发送系统中断实现的，然而操作系统感知不到协程的存在，所以协程自身是无法处理抢占的中断事件的。此外，如果一个用户态线程进行了 IO 操作，那操作系统会把整个线程阻塞，对应的没有调用 IO 的协程也会被阻塞。最后，由于操作系统的调度单位是进程，所以每次时间片分配到各个协程就更少了，所以 CPU 算力也是需要解决的一个问题。

也是因为这些问题吧，各个操作系统才进一步推出自己的系统级线程。

### Goroutine

Goroutine 其实是 Go 为了解决上述普通协程的问题而做出的更高层的封装。

> Go 的作者 Rob Pike 是这样描述 Goroutine 的：Goroutine 是一个于其他 Goroutine 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或多个 Goroutine 组成。它于线程、协程、进程等不同。它是一个 Goroutine。

对于上一节提到的早期协程，基本和线程的匹配模型都是*N:1*的，即一个线程需要同事维护多个协程。这样的构建模型就无法解决上述出现的问题。为此 Go 在语言提供了一种 GM 模型（后期逐渐演化为 GMP 模型），总体来说就是让用户态线程即 Goroutine(G) 和真正的线程 Machine(M) 成为一个*N:M*的模型，如下图所示：

![GM_01](https://image.dunbreak.cn/go/GM_01.webp)

可以看到 Goroutine 是依附在系统线程运行的。它们统一由 Go Runtime 管理，所以 Go 的核心其实就是它的 runtime，go runtime 内统一管理了 Goroutine 的创建销毁，和会统一给它们分配内存，响应系统调用等等，其内部包括了内存管理，进程管理，设备管理的主要功能，而真正的操作系统其实也就这么点功能，可以说 go runtime 就已经是**一个小型的操作系统**了。

Github 上有一个大佬，是百度的 Go 工程师，他自己用 Go 写了一个小操作系统[eggos](https://github.com/icexin/eggos)，并且成功把它装到了一个没有操作系统的裸机上，并且还能在里面玩超级马里奥。感兴趣的同学可以去学习了解一下，这种事在.net 平台几乎是无法实现的。

![GM_02](https://image.dunbreak.cn/go/GM_02.webp)

上图是早起（Go1.2 版本）Go 对 Goroutine 的调度模型。我们程序中新创建的 Goroutine 其实最开始是被加入了`global queue`这个队列中，然后程序真正的执行器 M 就会从这个队列中捞待调度的 Goroutine 来运行。当运行中的 Goroutine 触发了 IO 等系统调度时，runtime 会重新把它移回到 global queue 中。同样的，如果运行中的 Goroutine 内创建了新的 Goroutine，那同样也会把 Goroutine 放入 global queue 中等待调度。此外，runtime 还会启动一个监控线程监控这些运行中的 Goroutine，如果超过规定的时间片，那这些 Goroutine 就会被重新移回 global queue 中。

可以看到，GM 模型其实也是存在很多问题的，比如统一使用了一个全局锁，Goroutine 的调度依赖全局队列，程序执行器和 Goroutine 没有强依赖导致很多情况下不满足局部性原理，M 的内存分配和扩展等等。因此 Go 团队后期又进一步进化到了 GMP 模型，加入了一个 Processor，感兴趣的同学去学习了解[GMP 模型](https://learnku.com/articles/41728)。

综上，Goroutine 和线程相比，具有以下优势：

1. 很低的初始资源。一个 Goroutine 的创建成本直接从线程的 1-8MB**降到了默认 2KB**，由于不需要创建 TCB，Goroutine 只需要创建一个程序计数器的指针记录自己当前运行的函数栈位置即可。
2. 几乎没有上下文切换开销。一个 Goroutine 由 GoRuntime 调度，调度开销完全就是入队出队的操作，不需要切换上下文。和线程的 3.5us 相比，Goroutine 的[切换开销大概在 100ns 左右](https://zhuanlan.zhihu.com/p/80037638)。
3. 运行线程不会被阻塞。当 Goroutine 发出系统调用的时，其自身会被 runtime 直接调离 M，对应的 M 又会继续去执行新的 Goroutine 程序，极大地提高了线程利用率。

同时，结合 IO 多路复用技术和 runtime 调度，解决了早期协程一些严重性的问题，从而顺利从互联网时代突围出来，成为了各个大厂以及底层组件的主力语言。

### talk is cheap

好了，知道了 Goroutine 的各种优点，最后我们来看看一个 Go 的并发编程模型是如何实现的。

```go
func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func sayHello() {
	go say("hello")
	say("world")
}
```

这是 Go 官方文档中的 Goroutine 部分的一段示例。可以看到运行一段 Goroutine 的语法非常简单，就只需要一个 `go 关键字`即可。上述的例子最终会输出"hello world"。和 C#的传染性不同，Go 代码从外部是完全看不到代码是不是异步实现的，这就给开发者降低了一些心智压力。

我们知道，C#设计这套复杂的*async/await*模型，其实就是为了解决异步方法 callback 难以获取的问题。所以加入了 await 关键字，对异步状态机的结果监听，最终返回异步线程上下文中的结果。然而 Go 没有 await，那是如何进行上下文同步的呢？

```go
func calN(n int, ch chan<- int) {
  // 模拟复杂的N计算
  time.Sleep(time.Second)

  // 返回结果
  ch <- n * n
}

func main() {
  ch := make(chan int, 1)
  go calN(12345, ch)
  select {
    case ans := <-ch: {
      fmt.Printf("answer is: %d", ans)
    }
    default {
      time.Sleep(time.Millisecond * 100)
    }
  }
}
```

这里我们终于学到了最后一个关键字 `select` 以及最后一个引用类型 `chan` 了。

#### chan

先来说 chan，chan 是 channel 的意思，是多个 goroutine 进行数据传递的通道，其作用类似于 C#中的 Pipe，相当于是再多个并发执行的 goroutine 中掏了个洞洞用来传递数据。

chan 和指针一样是由类型的，是一个**引用类型**，通过`make()`函数初始化，第二个参数是通道的 size。由此可知，通道其实就是一个**双端队列**，多个 goroutine 都可以往通道中读写数据，当通道 buffer 被写满后，写通道的 goroutine 就会被**阻塞**。

写通道的语法特别简单就是一个箭头符号`<-`（注意只有左箭头唯一一种，没有右箭头），`ch<-`代表想通道写数据，`<-ch`代表从通道读出数据。

#### select

再来看 `select 关键字`，这里的 select 其实就是 linux 操作系统的 IO 多路复用技术的一个指令，其目的就是当接收到异步事件时*轮询每一个事件结果*。

Go 实现了语言级别的 select 功能，它的作用和 linux 的 select 类似，就是**阻塞当前 goroutine**等待 chan 的返回。

通常 select 会配合 case 和 default 使用，使用方式类似于 switch-case 语句，满足哪一个就触发哪一个。上述代码中，当我使用`select关键字`读取通道内的数据时，由于刚开始`caN`函数还没有返回，所以 main 的 goroutine 进入了 default 会睡 100 毫秒。之后再次循环之前的操作直至某个 case 中有 return 等退出的语句。

如果同一时间同事满足了多个 case，那 Go Runtime 会**随机选择一个 case 去执行**。通常情况下，Goroutine 的超时都是自己写一个超时函数实现的，比如下列代码：

```go
func makeNum(ch chan<- int) {
	time.Sleep(5 * time.Second)
	ch <- 10
}

func timeout(ch chan<- int) {
	time.Sleep(3 * time.Second)
	ch <- 0
}

func chanBlock() {
	ch := make(chan int, 1)
	timeoutCh := make(chan int, 1)
	go makeNum(ch)
	go timeout(timeoutCh)
	select {
	case <-ch:
		fmt.Println(ch)
	case <-timeoutCh:
		fmt.Println("timeout")
	}
}
```

#### 生产者-消费者模型

好了，为了更熟练地理解 Goroutine 的编程风格，最后让我们用 Goroutine 实现一个操作系统同步互斥问题中比较经典的`生产者-消费者`模型：

```go
// 需求：创建生产者消费者模型，其中生产者和消费者分别是N和M个
// 生产者每隔一段时间生产X产品，消费者同样也每隔一段时间消费Y产品
// 生产者如果将产品容器填满应该被阻塞，多次阻塞之后将会退出
// 每个消费者需要消费满Z个产品才能退出，否则就要一直消费产品

const (
	ProducerCount = 3   // 生产者数量
	ConsumerCount = 5   // 消费者数量
	FullCount     = 15  // 消费者需求数量，消费者吃够了应该回家
	TimeFactor    = 5   // 时间间隔因子，每生产/消费一个产品，需要休息一段时间
  QuitTimes     = 3   // 生产者退出次数，如果生产者阻塞了多次，则会下班
  SleepFactor   = 3   // 睡眠时间因子，如果生产者被阻塞应该睡眠一段时间
)

var (
	waitGroup = sync.WaitGroup{}
)

func producer(n int, ch chan<- int) {
	defer waitGroup.Done()
	times := createFactor()
	asleepTimes := 0
	for true {
		p := createFactor()
		select {
		case ch <- p:
			{
				t := time.Duration(times) * time.Second
				fmt.Printf("Producer: %d produced a %d, then will sleep %d s\n", n, p, times)
				time.Sleep(t)
			}
		default:
			{
				time.Sleep(time.Second * SleepFactor)
				asleepTimes++
				fmt.Println("I need consumers!")
				if asleepTimes == QuitTimes {
					fmt.Printf("Producer %d will go home\n", n)
					return
				}
			}
		}
	}
}

func consumer(n int, ch chan int) {
	waitGroup.Done()
	s := make([]int, 0, FullCount)
	times := createFactor()
	for len(s) < FullCount {
		select {
		case c := <-ch:
			{
				s = append(s, c)
				fmt.Printf("Consumer: %d consume a %d, remains %d, then will sleep %d s\n", n, c, FullCount-len(s), times)
				time.Sleep(time.Duration(times) * time.Second)
			}
		default:
			{
				fmt.Println("Producers need to hurry up, I'm hungry!")
				time.Sleep(time.Second * SleepFactor)
			}
		}
	}
	fmt.Printf("Consumer: %d already full\n", n)
}

func createFactor() int {
	times := 0
	for times == 0 {
		times = rand.Intn(TimeFactor)
	}
	return times
}

func main() {
	rand.Seed(time.Now().UnixNano())
	ch := make(chan int, FullCount)

	waitGroup.Add(ProducerCount)
	for i := 0; i < ProducerCount; i++ {
		go producer(i, ch)
	}

	waitGroup.Add(ConsumerCount)
	for i := 0; i < ConsumerCount; i++ {
		go consumer(i, ch)
	}

	waitGroup.Wait()
}
```

这里用到了 Goroutine 中另一个比较常见的包`sync`，上例中用到了一个 WaitGroup，其目的类似于 C#中的`Task.WaitAll`，用来等待所有的 goroutine 执行结束。可以看到它基本是基于`信号量`实现的，所以每次创建 goroutine 时，都需要执行 Add 函数。

## 如何优雅地摆一个可爱的造型

好了，至此 Go 语言的所有基本功能和语法就都已经介绍完毕了（其实还有反射，但是我觉得 Go 的反射实现的不太行，语法诡异所以就不介绍了），但是光看这些文字是没办法学会 Go 的，作为一个工科，软件行业是需要反复地练习来逐步熟练的。

最开始，我是通过强制自己用 Go 刷 LeetCode，但是效果不是很好，因为有些算法题本来就很复杂，光理解都需要花很多功夫，再用上一个自己不熟练的语言，简直完美的达到了事倍功半的效果。

那既然 Go 的大部分使用需求都是用来开发互联网服务的，我觉得我们就有必要做一个小练习，用 Go 来开发一个 Web 服务。

### Hello, World

Go 原生自带的 net 包是 Go 用来开发 Web 项目的基础组件，其中 net 对应的是七层网络协议的 TCP/IP 层，这一层太过底层了，不适合我们这些学习的新手，所以我们从应用层的 net.http 包来实现一个 Web 版的 Hello，World 小程序。

其实，net.http 包下有一个函数`ListenAndServe`，这个函数就是用来创建一个 Web 服务的，其第一个参数是站点地址，而第二个参数是一个 Handler 接口。那是不是只要我们实现了这个接口，就可以写一个最简单的 hello, world 站点了呢？没错，就是这么简单~

```go
// 创建一个Server结构体
type Server struct {}

// 为结构体实现http.Handler接口，这个接口就只有这一个函数
func (s *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {
  w.Write(json.Marshal("hello, world"))
}

func main() {
  http.ListenAndServe("localhost:8080", &Server{})
}
```

直接执行上述的代码，好家伙齐活了。就三句代码就真启动了一个运行在 8080 端口的最简单的 Web 服务。

VS2022 发布之后，C#10 也可以使用三句话发布一个 hello, world 服务了，代码如下。感兴趣的同学可以去尝试一下，C#10 中，默认删除了 Main 函数中的各种引用和类，让 C#看起来更像是一个“主流”语言了，为微软公司点赞。

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () => "Hello World").Run();
```

### Toy-Web

有了上述的基础概念，我们就可以写一个练手项目，真正的开发点属于自己的东西了。

上述的 Hello, World 虽然建站简单，但是缺少几个常用 Web 框架的主要功能：

1. 路由，没有路由所有的请求都只能返回 HelloWorld 吗？那肯定没法用了
2. 中间件，现在公司的业务大量使用到了中间件实现各种逻辑，我觉得实现一个中间件也是一次不错的尝试
3. 上下文封装，从 Hello，World 程序中我们可以看到，请求的响应我是通过 w.Write 函数拼接一个 Json 实现的，但是日常开发中我们都不会去处理这些东西，因此需要封装起来统一处理

其实还有更多的复杂功能，往简单说有 MVC 分层，Action 请求参数自动解析，往难了说还有 Ioc 和 Aop…但是万事开头难，让我们先想办法实现上面三个最简单的功能。

我的最终目标是，同我们自己写的 Toy-Web 写一个所有网络开发的必修练习`图书管理系统`的后台 Api 服务。

这个小项目的讲解就不属于 Go 语言的基本范畴了，因为内部大多都是设计的问题，语法就那么一点，重点是要看怎么做一个代码简洁并且有扩展性健壮性的程序。

比如我可以说几个点：

1. Server 其实应该设计为一个 IServer 接口提供最简单的 Start 和 Shutdown 服务，以为 Server 肯定是会有版本变更的，HelloWorld 那种直接写死就堵死了扩展性
2. 上下文可以抽象为一个 IContext 接口，对外暴露各种封装请求以及需要封装一个 Go 的 Context 库用来处理后续的请求超时断开等功能
3. 路由同样也应该抽象为一个 IRouter 接口，其中有一个 Map 函数来注册路由，可以明确的是路由应该很大可能有多个版本的。因为最开始，我们的路由可能只能做简单的 map 匹配，随着我们对 Go 语言语法的熟悉，应该想办法实现通配符的匹配逻辑，即我 Map("hello/\*")应该把所有的 hello 之后的请求都解析到对应的 Action 中。后续可能还会增加正则表达式，路径参数等需求，所以路由的设计也是一个重点
4. 可以学习 C#，将路由的处理 Handler 封装为一个 Action，这样做的好处是可以很完美的支持中间件，中间件的语法我在之前介绍函数的时候已经写好了，可以直接使用

最后，提供一个我自己纯手工每一行代码都是自己实现的[Toy-Web](https://github.com/lzl82891314/training-go-2/tree/main/src/toy-web)。这个练手的小项目也花了我很大的精力才完成，真正想要自己实现其实也需要一点算法功底，比如路由应该使用 Trie 树，匹配通配符需要 BFS 和 DFS 的知识，如果需要路由节点扩展，则需要会回溯的算法。总之，万丈高楼平地起，加油吧，各位新生的 Gopher 们，祝我们都有一个美好的未来。
